# Formal Proofs

This [crlf](README.md) language encodes the components of a proof.

```javascript
{
    "lang": "proof",
    "ast": <abt>
}
```

## Abstract Syntax Trees (ast)

An _abstract syntax tree_ (ast) represents the structure of a program. 
The leaves are _variables_, which represent place-holders for subordinate ast’s. 
The nodes are _operators_ which combine zero or more subordinate ast’s.

* AST
    * Variable
    * Operator

Ast’s are classified into a variety of _sorts_ corresponding to different forms of syntax. 

### Variable

```javascript
{
    "kind": "variable",
    "sort": <string>,
    "name": <string>
}
```

A _variable_ stands for an unspecified, or generic, piece of syntax of a specified sort. 
Variables are given meaning by substitution.

### Operator

```javascript
{
    "kind": "operator",
    "sort": <string>,
    "name": <string>,
    "arguments": [..., <ast>]
}
```

Ast’s can be combined by an _operator_, 
which has an _arity_ specifying the sort of the operator and the number and sorts of its arguments. 
An operator of sort <var>s</var> and arity <var>s</var><sub>1</sub>,...,<var>s</var><sub>_n_</sub> combines <var>n</var> ≥ 0 ast’s of sort <var>s</var><sub>1</sub>,...,<var>s</var><sub><var>n</var></sub>, respectively, into a compound ast of sort <var>s</var>.

Operators may be _indexed_ to create a _family_ of similar operators. This is indicated by the presence of an optional `index` property.

### Example: Arithmetic Expressions

As an example, 
consider a language of arithmetic expressions built from numbers, addition, and multiplication. 
The abstract syntax of such a language consists of a single sort **Exp** generated by these operators:

1. An operator `num`<sub>[<var>n</var>]</sub> of sort **Exp** for each <var>n</var> ∈ ℕ;
2. Two operators, `plus` and `times`, of sort **Exp**, each with two arguments of sort **Exp**.

The expression 2 × (3 + <var>x</var>) which involves a variable, <var>x</var>, would be represented by the ast:

<pre align="center">
times(num[2];plus(num[3];<var>x</var>))
</pre>

Expressed as nested lists this would be:

* `times`
    * `num`<sub>[2]</sub>
    * `plus`
        * `num`<sub>[3]</sub>
        * <var>x</var>

Expressed with _crlf_ this would look like:

```javascript
{ "kind":"operator", "sort":"Exp", "name":"times", "arguments":[
    { "kind":"operator", "sort":"Exp", "name":"num", "index":2, "arguments":[] },
    { "kind":"operator", "sort":"Exp", "name":"plus", "arguments":[
        { "kind":"operator", "sort":"Exp", "name":"num", "index":3, "arguments":[] },
        { "kind":"variable", "sort":"Exp", "name":"x" }
    ]}
]}
```

## Abstract Binding Trees (abt)

An _abstract binding tree_ (abt) enriches an ast with the means to introduce new variables and symbols,
called a _binding_, 
with a specified range of significance, 
called its _scope_.

* ABT
    * Variable
    * Operator
    * Binder

### Binder

```javascript
{
    "kind": "binder",
    "bindings": {..., <string>:<string>},
    "scope": <abt>
}
```

The `bindings` are a mapping from symbol names to sorts. The `scope` is the abt within which the symbols are bound.

----

### Rule Examples

| rule | (4.1f)
|------|----
|      | Γ ⊢ <var>e</var><sub>1</sub> : str
| ∧    | Γ ⊢ <var>e</var><sub>2</sub> : str
| ⇒    | Γ ⊢ cat(<var>e</var><sub>1</sub>;<var>e</var><sub>2</sub>) : str

```javascript
{ "kind":"operator", "sort":"Logic", "name":"implication", "arguments":[
    { "kind":"operator", "sort":"Logic", "name":"conjunction", "arguments":[
        { "kind":"operator", "sort":"Logic", "name":"inference", "arguments":[
            { "kind":"variable", "sort":"Logic", "name":"Γ" },
            { "kind":"operator", "sort":"Predicate", "name":"has-type", "arguments":[
                { "kind":"variable", "sort":"Term", "name":"e_1" },
                { "kind":"operator", "sort":"Type", "name":"str", "arguments":[] }
            ]}
        ]},
        { "kind":"operator", "sort":"Logic", "name":"inference", "arguments":[
            { "kind":"variable", "sort":"Logic", "name":"Γ" },
            { "kind":"operator", "sort":"Predicate", "name":"has-type", "arguments":[
                { "kind":"variable", "sort":"Term", "name":"e_2" },
                { "kind":"operator", "sort":"Type", "name":"str", "arguments":[] }
            ]}
        ]}
    ]},
    { "kind":"operator", "sort":"Logic", "name":"inference", "arguments":[
        { "kind":"variable", "sort":"Logic", "name":"Γ" },
        { "kind":"operator", "sort":"Predicate", "name":"has-type", "arguments":[
            { "kind":"operator", "sort":"Term", "name":"cat", "arguments": [
                { "kind":"variable", "sort":"Term", "name":"e_1" },
                { "kind":"variable", "sort":"Term", "name":"e_2" }
            ]},
            { "kind":"operator", "sort":"Type", "name":"str", "arguments":[] }
        ]}
    ]}
]}
```

| rule | (4.1g)
|------|----
|      | Γ ⊢ <var>e</var> : str
| ⇒    | Γ ⊢ len(<var>e</var>) : num

```javascript
{ "kind":"operator", "sort":"Logic", "name":"implication", "arguments":[
    { "kind":"operator", "sort":"Logic", "name":"conjunction", "arguments":[
        { "kind":"operator", "sort":"Logic", "name":"inference", "arguments":[
            { "kind":"variable", "sort":"Logic", "name":"Γ" },
            { "kind":"operator", "sort":"Predicate", "name":"has-type", "arguments":[
                { "kind":"variable", "sort":"Term", "name":"e" },
                { "kind":"operator", "sort":"Type", "name":"str", "arguments":[] }
            ]}
        ]}
    ]},
    { "kind":"operator", "sort":"Logic", "name":"inference", "arguments":[
        { "kind":"variable", "sort":"Logic", "name":"Γ" },
        { "kind":"operator", "sort":"Predicate", "name":"has-type", "arguments":[
            { "kind":"operator", "sort":"Term", "name":"len", "arguments": [
                { "kind":"variable", "sort":"Term", "name":"e" }
            ]},
            { "kind":"operator", "sort":"Type", "name":"num", "arguments":[] }
        ]}
    ]}
]}
```

| rule | (4.1h)
|------|----
|      | Γ ⊢ <var>e</var><sub>1</sub> : <var>τ</var><sub>1</sub>
| ∧    | Γ, <var>x</var> : <var>τ</var><sub>1</sub> ⊢ <var>e</var><sub>2</sub> : <var>τ</var><sub>2</sub>
| ⇒    | Γ ⊢ let(<var>e</var><sub>1</sub>;<var>x</var>.<var>e</var><sub>2</sub>) : <var>τ</var><sub>2</sub>

```javascript
{ "kind":"operator", "sort":"Logic", "name":"implication", "arguments":[
    { "kind":"operator", "sort":"Logic", "name":"conjunction", "arguments":[
        { "kind":"operator", "sort":"Logic", "name":"inference", "arguments":[
            { "kind":"variable", "sort":"Logic", "name":"Γ" },
            { "kind":"operator", "sort":"Predicate", "name":"has-type", "arguments":[
                { "kind":"variable", "sort":"Term", "name":"e_1" },
                { "kind":"variable", "sort":"Type", "name":"τ_1" }
            ]}
        ]},
        { "kind":"operator", "sort":"Logic", "name":"inference", "arguments":[
            { "kind":"operator", "sort":"Logic", "name":"conjunction", "arguments":[
                { "kind":"variable", "sort":"Logic", "name":"Γ" },
                { "kind":"operator", "sort":"Predicate", "name":"has-type", "arguments":[
                    { "kind":"variable", "sort":"Term", "name":"x" },
                    { "kind":"variable", "sort":"Type", "name":"τ_1" }
                ]}
            ]},
            { "kind":"operator", "sort":"Predicate", "name":"has-type", "arguments":[
                { "kind":"variable", "sort":"Term", "name":"e_2" },
                { "kind":"variable", "sort":"Type", "name":"τ_2" }
            ]}
        ]}
    ]},
    { "kind":"operator", "sort":"Logic", "name":"inference", "arguments":[
        { "kind":"variable", "sort":"Logic", "name":"Γ" },
        { "kind":"operator", "sort":"Predicate", "name":"has-type", "arguments":[
            { "kind":"operator", "sort":"Term", "name":"let", "arguments": [
                { "kind":"variable", "sort":"Term", "name":"e_1" },
                { "kind":"binder", "bindings":{"x":"τ_1"}, "scope":
                    { "kind":"variable", "sort":"Term", "name":"e_2" }
                }
            ]},
            { "kind":"variable", "sort":"Type", "name":"τ_2" }
        ]}
    ]}
]}
```

| rule | (5.4g)
|------|----
|      | <var>e</var><sub>1</sub> ↦ <var>e′</var><sub>1</sub>
| ⇒    | let(<var>e</var><sub>1</sub>;<var>x</var>.<var>e</var><sub>2</sub>) ↦ let(<var>e′</var><sub>1</sub>;<var>x</var>.<var>e</var><sub>2</sub>)

```javascript
{ "kind":"operator", "sort":"Logic", "name":"implication", "arguments":[
    { "kind":"operator", "sort":"Logic", "name":"conjunction", "arguments":[
        { "kind":"operator", "sort":"Predicate", "name":"maps-to", "arguments":[
            { "kind":"variable", "sort":"Term", "name":"e_1" },
            { "kind":"variable", "sort":"Term", "name":"e′_1" }
        ]}
    ]},
    { "kind":"operator", "sort":"Predicate", "name":"maps-to", "arguments":[
        { "kind":"operator", "sort":"Term", "name":"let", "arguments": [
            { "kind":"variable", "sort":"Term", "name":"e_1" },
            { "kind":"binder", "bindings":{"x":"τ"}, "scope":
                { "kind":"variable", "sort":"Term", "name":"e_2" }
            }
        ]},
        { "kind":"operator", "sort":"Term", "name":"let", "arguments": [
            { "kind":"variable", "sort":"Term", "name":"e′_1" },
            { "kind":"binder", "bindings":{"x":"τ"}, "scope":
                { "kind":"variable", "sort":"Term", "name":"e_2" }
            }
        ]}
    ]}
]}
```

| rule | (5.4h)
|------|----
|      | <var>e</var><sub>1</sub> val
| ⇒    | let(<var>e</var><sub>1</sub>;<var>x</var>.<var>e</var><sub>2</sub>) ↦ [<var>e</var><sub>1</sub>/<var>x</var>]<var>e</var><sub>2</sub>

```javascript
{ "kind":"operator", "sort":"Logic", "name":"implication", "arguments":[
    { "kind":"operator", "sort":"Logic", "name":"conjunction", "arguments":[
        { "kind":"operator", "sort":"Predicate", "name":"has-sort", "arguments":[
            { "kind":"variable", "sort":"Term", "name":"e" },
            { "kind":"operator", "sort":"Sort", "name":"val", "arguments":[] }
        ]}
    ]},
    { "kind":"operator", "sort":"Predicate", "name":"maps-to", "arguments":[
        { "kind":"operator", "sort":"Term", "name":"let", "arguments": [
            { "kind":"variable", "sort":"Term", "name":"e_1" },
            { "kind":"binder", "bindings":{"x":"τ"}, "scope":
                { "kind":"variable", "sort":"Term", "name":"e_2" }
            }
        ]},
        { "kind":"operator", "sort":"Term", "name":"substitute", "arguments": [
            { "kind":"variable", "sort":"Term", "name":"e_1" },
            { "kind":"variable", "sort":"τ", "name":"x" },
            { "kind":"variable", "sort":"Term", "name":"e_2" }
        ]}
    ]}
]}
```

----

## Legacy Notes...

Abstract Binding Trees support a _replace_ operation `<abt>.replace { "name":<string>, "abt":<abt> }` which replaces all occurances of the named variable in the target with the `abt` parameter. Note that the `sort` of the abt must match the `sort` of the variable.

### Value

```javascript
{
    "kind": "value",
    "sort": <string>,
    "value": <value>
}
```

### Variable

```javascript
{
    "kind": "variable",
    "sort": <string>,
    "name": <string>
}
```

Stands for an unspecified piece of syntax of a given `sort`. Variables are given meaning by substitution.

### Operator

```javascript
{
    "kind": "operator",
    "sort": <string>,
    "name": <string>,
    "argument": <object>
}
```

A combiner whose result has a given `sort`. The `argument` maps named properties to _abt_'s, each with an expected _sort_.

### Abstractor

```javascript
{
    "kind": "abstractor",
    "names": <array>,
    "abt": <abt>
}
```

Binds zero or more named variables in `abt`.

## Proof Components

### Judgement

```javascript
{
    "kind": "judgement",
    "relation": <string>,
    "abt": <abt>
}
```

Asserts that `abt` has a specific property or conforms the specifed relation.

### Rule

```javascript
{
    "kind": "rule",
    "name": <string>,
    "premises": <array>,
    "conclusion": <judgement>
}
```

The `premises` are a list of zero or more _judgement_'s. The `name` is optional documentation used in a derivation.

### Derivation

```javascript
{
    "kind": "derivation",
    "rule": <string>,
    "premises": <array>,
    "conclusion": <judgement>
}
```

A _derivation_ is tree of _rule_'s where the leaves are _judgement_'s. The `premises` are a list of zero or more _derivation_'s or _judgement_'s. The `rule` is optional documentation of the _rule_ applied.

### Type Judgement

Γ ⊢ _e_ : τ

```javascript
{
    "kind": "type-judgement",
    "context": <object>,
    "expression": <abt>,
    "type": <string>
}
```

∀∃•Γ≠≡χλ∈∉ℕ×ℤ⟨⟩∅⊤⊥∨∧⊢↦→⇒↑↓⇓ _x_′′″‴

#### Example: nat

```javascript
{
    "kind": "rule",
    "name": "(2.2a)",
    "premises": [],
    "conclusion": {
        "kind": "judgement",
        "relation": "nat",
        "abt": {
            "kind": "operator",
            "sort": "Exp",
            "name": "zero",
            "argument": {}
        }
    }
}
```

```javascript
{
    "kind": "rule",
    "name": "(2.2b)",
    "premises": [
        {
            "kind": "judgement",
            "relation": "nat",
            "abt": {
                "kind": "variable",
                "sort": "Exp",
                "name": "a"
            }
        }
    ],
    "conclusion": {
        "kind": "judgement",
        "relation": "nat",
        "abt": {
            "kind": "operator",
            "sort": "Exp",
            "name": "succ",
            "argument": {
                "n": {
                    "kind": "variable",
                    "sort": "Exp",
                    "name": "a"
                }
            }
        }
    }
}
```

#### Example: tree

```javascript
{
    "kind": "rule",
    "name": "(2.3a)",
    "premises": [],
    "conclusion": {
        "kind": "judgement",
        "relation": "tree",
        "abt": {
            "kind": "operator",
            "sort": "Exp",
            "name": "empty",
            "argument": {}
        }
    }
}
```

```javascript
{
    "kind": "rule",
    "name": "(2.3b)",
    "premises": [
        {
            "kind": "judgement",
            "relation": "tree",
            "abt": {
                "kind": "variable",
                "sort": "Exp",
                "name": "a_1"
            }
        },
        {
            "kind": "judgement",
            "relation": "tree",
            "abt": {
                "kind": "variable",
                "sort": "Exp",
                "name": "a_2"
            }
        }
    ],
    "conclusion": {
        "kind": "judgement",
        "relation": "tree",
        "abt": {
            "kind": "operator",
            "sort": "Exp",
            "name": "node",
            "argument": {
                "left": {
                    "kind": "variable",
                    "sort": "Exp",
                    "name": "a_1"
                },
                "right": {
                    "kind": "variable",
                    "sort": "Exp",
                    "name": "a_2"
                }
            }
        }
    }
}
```

## References

* Harper, Robert. [_Practical Foundations for Programming Languages_, 2nd edition](https://www.cs.cmu.edu/~rwh/pfpl/2nded.pdf). Cambridge University Press, NY (2012).
