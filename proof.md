# Formal Proofs

This [crlf](README.md) language encodes the components of a proof.

```javascript
{
    "lang": "proof",
    "ast": <abt>
}
```

## Abstract Syntax Trees (ast)

An _abstract syntax tree_ represents the structure of a program. 
The leaves are _variables_, which represent place-holders for subordinate Ast’s. 
The nodes are _operators_ which combine subordinate Ast’s.

* AST
  * Variable
  * Operator

Ast’s are classified into a variety of _sorts_ corresponding to different forms of syntax. 

### Variable

```javascript
{
    "kind": "variable",
    "sort": <string>,
    "name": <string>
}
```

A _variable_ stands for an unspecified, or generic, piece of syntax of a specified sort. 
Variables are given meaning by substitution.

### Operator

```javascript
{
    "kind": "operator",
    "sort": <string>,
    "name": <string>,
    "arguments": [..., <ast>]
}
```

Ast’s can be combined by an _operator_, 
which has an _arity_ specifying the sort of the operator and the number and sorts of its arguments. 
An operator of sort _s_ and arity _s_<sub>1</sub>, . . . ,_s_<sub>_n_</sub> combines _n_ ≥ 0 ast’s of sort _s_<sub>1</sub>, . . . ,_s_<sub>_n_</sub>, respectively, into a compound ast of sort _s_.

Operators may be _indexed_ to create a _family_ of similar operators. This is indicated by the presence of an optional `index` property.

### Example: Arithmetic Expressions

As an example, 
consider a language of arithmetic expressions built from numbers, addition, and multiplication. 
The abstract syntax of such a language consists of a single sort **Exp** generated by these operators:

1. An operator `num`[_n_] of sort **Exp** for each _n_ ∈ ℕ;

----

## Abstract Binding Trees (abt)

Abstract Binding Trees support a _replace_ operation `<abt>.replace { "name":<string>, "abt":<abt> }` which replaces all occurances of the named variable in the target with the `abt` parameter. Note that the `sort` of the abt must match the `sort` of the variable.

### Value

```javascript
{
    "kind": "value",
    "sort": <string>,
    "value": <value>
}
```

### Variable

```javascript
{
    "kind": "variable",
    "sort": <string>,
    "name": <string>
}
```

Stands for an unspecified piece of syntax of a given `sort`. Variables are given meaning by substitution.

### Operator

```javascript
{
    "kind": "operator",
    "sort": <string>,
    "name": <string>,
    "argument": <object>
}
```

A combiner whose result has a given `sort`. The `argument` maps named properties to _abt_'s, each with an expected _sort_.

### Abstractor

```javascript
{
    "kind": "abstractor",
    "names": <array>,
    "abt": <abt>
}
```

Binds zero or more named variables in `abt`.

## Proof Components

### Judgement

```javascript
{
    "kind": "judgement",
    "relation": <string>,
    "abt": <abt>
}
```

Asserts that `abt` has a specific property or conforms the specifed relation.

### Rule

```javascript
{
    "kind": "rule",
    "name": <string>,
    "premises": <array>,
    "conclusion": <judgement>
}
```

The `premises` are a list of zero or more _judgement_'s. The `name` is optional documentation used in a derivation.

### Derivation

```javascript
{
    "kind": "derivation",
    "rule": <string>,
    "premises": <array>,
    "conclusion": <judgement>
}
```

A _derivation_ is tree of _rule_'s where the leaves are _judgement_'s. The `premises` are a list of zero or more _derivation_'s or _judgement_'s. The `rule` is optional documentation of the _rule_ applied.

### Type Judgement

Γ ⊢ _e_ : τ

```javascript
{
    "kind": "type-judgement",
    "context": <object>,
    "expression": <abt>,
    "type": <string>
}
```

∀∃•Γ≠≡χλ∈∉ℕ×ℤ⟨⟩∅⊤⊥∨∧⊢↦→⇒↑↓⇓ _x_′′″‴

#### Example: nat

```javascript
{
    "kind": "rule",
    "name": "(2.2a)",
    "premises": [],
    "conclusion": {
        "kind": "judgement",
        "relation": "nat",
        "abt": {
            "kind": "operator",
            "sort": "Exp",
            "name": "zero",
            "argument": {}
        }
    }
}
```

```javascript
{
    "kind": "rule",
    "name": "(2.2b)",
    "premises": [
        {
            "kind": "judgement",
            "relation": "nat",
            "abt": {
                "kind": "variable",
                "sort": "Exp",
                "name": "a"
            }
        }
    ],
    "conclusion": {
        "kind": "judgement",
        "relation": "nat",
        "abt": {
            "kind": "operator",
            "sort": "Exp",
            "name": "succ",
            "argument": {
                "n": {
                    "kind": "variable",
                    "sort": "Exp",
                    "name": "a"
                }
            }
        }
    }
}
```

#### Example: tree

```javascript
{
    "kind": "rule",
    "name": "(2.3a)",
    "premises": [],
    "conclusion": {
        "kind": "judgement",
        "relation": "tree",
        "abt": {
            "kind": "operator",
            "sort": "Exp",
            "name": "empty",
            "argument": {}
        }
    }
}
```

```javascript
{
    "kind": "rule",
    "name": "(2.3b)",
    "premises": [
        {
            "kind": "judgement",
            "relation": "tree",
            "abt": {
                "kind": "variable",
                "sort": "Exp",
                "name": "a_1"
            }
        },
        {
            "kind": "judgement",
            "relation": "tree",
            "abt": {
                "kind": "variable",
                "sort": "Exp",
                "name": "a_2"
            }
        }
    ],
    "conclusion": {
        "kind": "judgement",
        "relation": "tree",
        "abt": {
            "kind": "operator",
            "sort": "Exp",
            "name": "node",
            "argument": {
                "left": {
                    "kind": "variable",
                    "sort": "Exp",
                    "name": "a_1"
                },
                "right": {
                    "kind": "variable",
                    "sort": "Exp",
                    "name": "a_2"
                }
            }
        }
    }
}
```

## References

* Harper, Robert. [_Practical Foundations for Programming Languages_, 2nd edition](https://www.cs.cmu.edu/~rwh/pfpl/2nded.pdf). Cambridge University Press, NY (2012).
