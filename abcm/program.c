/*
 * program.c -- bootstrap program
 */
#include <stddef.h>  // for NULL, size_t, et. al.
#include <assert.h>

#include "program.h"
#include "bose.h"
#include "sponsor.h"
#include "array.h"
#include "object.h"
#include "equiv.h"
#include "print.h"
#include "abcm.h"

#define LOG_ALL // enable all logging
#include "log.h"

/*
BYTE bootstrap[] = {  // non-memoized 2-actor, 2-event testcase
    0x06, 0x10, 0x82, 0xd8, 0x04, 0x81, 0x07, 0x10, 0x82, 0xd2, 0x04, 0x84, 0x0a, 0x84, 0x6b, 0x69,  // ···Ø·····Ò····ki
    0x6e, 0x64, 0x0a, 0x8d, 0x61, 0x63, 0x74, 0x6f, 0x72, 0x5f, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x6f,  // nd··actor_sponso
    0x72, 0x0a, 0x86, 0x61, 0x63, 0x74, 0x6f, 0x72, 0x73, 0x82, 0x0a, 0x86, 0x65, 0x76, 0x65, 0x6e,  // r··actors···even
    0x74, 0x73, 0x82, 0x0a, 0x86, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x06, 0x10, 0x82, 0x9d, 0x04,  // ts···script·····
    0x83, 0x07, 0x10, 0x82, 0x10, 0x01, 0x83, 0x0a, 0x84, 0x6b, 0x69, 0x6e, 0x64, 0x0a, 0x8c, 0x61,  // ·········kind··a
    0x63, 0x74, 0x6f, 0x72, 0x5f, 0x61, 0x73, 0x73, 0x69, 0x67, 0x6e, 0x0a, 0x84, 0x6e, 0x61, 0x6d,  // ctor_assign··nam
    0x65, 0x0a, 0x85, 0x61, 0x6c, 0x65, 0x72, 0x74, 0x0a, 0x85, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x07,  // e··alert··value·
    0x10, 0x82, 0xe2, 0x00, 0x83, 0x0a, 0x84, 0x6b, 0x69, 0x6e, 0x64, 0x0a, 0x8c, 0x61, 0x63, 0x74,  // ··â····kind··act
    0x6f, 0x72, 0x5f, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x0a, 0x85, 0x73, 0x74, 0x61, 0x74, 0x65,  // or_create··state
    0x07, 0xab, 0x83, 0x0a, 0x84, 0x6b, 0x69, 0x6e, 0x64, 0x0a, 0x8c, 0x65, 0x78, 0x70, 0x72, 0x5f,  // ·«···kind··expr_
    0x6c, 0x69, 0x74, 0x65, 0x72, 0x61, 0x6c, 0x0a, 0x84, 0x74, 0x79, 0x70, 0x65, 0x0a, 0x86, 0x4f,  // literal··type··O
    0x62, 0x6a, 0x65, 0x63, 0x74, 0x0a, 0x85, 0x63, 0x6f, 0x6e, 0x73, 0x74, 0x03, 0x0a, 0x88, 0x62,  // bject··const···b
    0x65, 0x68, 0x61, 0x76, 0x69, 0x6f, 0x72, 0x07, 0x10, 0x82, 0x8a, 0x00, 0x83, 0x0a, 0x84, 0x6b,  // ehavior········k
    0x69, 0x6e, 0x64, 0x0a, 0x8e, 0x61, 0x63, 0x74, 0x6f, 0x72, 0x5f, 0x62, 0x65, 0x68, 0x61, 0x76,  // ind··actor_behav
    0x69, 0x6f, 0x72, 0x0a, 0x84, 0x6e, 0x61, 0x6d, 0x65, 0x0f, 0x0a, 0x86, 0x73, 0x63, 0x72, 0x69,  // ior··name···scri
    0x70, 0x74, 0x06, 0xe2, 0x81, 0x07, 0xdf, 0x83, 0x0a, 0x84, 0x6b, 0x69, 0x6e, 0x64, 0x0a, 0x89,  // pt·â··ß···kind··
    0x6c, 0x6f, 0x67, 0x5f, 0x70, 0x72, 0x69, 0x6e, 0x74, 0x0a, 0x85, 0x6c, 0x65, 0x76, 0x65, 0x6c,  // log_print··level
    0x81, 0x0a, 0x85, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x07, 0xbc, 0x83, 0x0a, 0x84, 0x6b, 0x69, 0x6e,  // ···value·¼···kin
    0x64, 0x0a, 0x88, 0x64, 0x69, 0x63, 0x74, 0x5f, 0x67, 0x65, 0x74, 0x0a, 0x84, 0x6e, 0x61, 0x6d,  // d··dict_get··nam
    0x65, 0x0a, 0x87, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x0a, 0x82, 0x69, 0x6e, 0x07, 0x96,  // e··message··in··
    0x81, 0x0a, 0x84, 0x6b, 0x69, 0x6e, 0x64, 0x0a, 0x8d, 0x61, 0x63, 0x74, 0x6f, 0x72, 0x5f, 0x6d,  // ···kind··actor_m
    0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x07, 0x10, 0x82, 0xa7, 0x02, 0x83, 0x0a, 0x84, 0x6b, 0x69,  // essage···§····ki
    0x6e, 0x64, 0x0a, 0x8c, 0x61, 0x63, 0x74, 0x6f, 0x72, 0x5f, 0x61, 0x73, 0x73, 0x69, 0x67, 0x6e,  // nd··actor_assign
    0x0a, 0x84, 0x6e, 0x61, 0x6d, 0x65, 0x0a, 0x82, 0x6f, 0x6b, 0x0a, 0x85, 0x76, 0x61, 0x6c, 0x75,  // ··name··ok··valu
    0x65, 0x07, 0x10, 0x82, 0x7c, 0x02, 0x83, 0x0a, 0x84, 0x6b, 0x69, 0x6e, 0x64, 0x0a, 0x8c, 0x61,  // e···|····kind··a
    0x63, 0x74, 0x6f, 0x72, 0x5f, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x0a, 0x85, 0x73, 0x74, 0x61,  // ctor_create··sta
    0x74, 0x65, 0x07, 0x10, 0x82, 0x8b, 0x00, 0x84, 0x0a, 0x84, 0x6b, 0x69, 0x6e, 0x64, 0x0a, 0x89,  // te········kind··
    0x64, 0x69, 0x63, 0x74, 0x5f, 0x62, 0x69, 0x6e, 0x64, 0x0a, 0x84, 0x6e, 0x61, 0x6d, 0x65, 0x0a,  // dict_bind··name·
    0x85, 0x6c, 0x61, 0x62, 0x65, 0x6c, 0x0a, 0x85, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x07, 0xb0, 0x83,  // ·label··value·°·
    0x0a, 0x84, 0x6b, 0x69, 0x6e, 0x64, 0x0a, 0x8c, 0x65, 0x78, 0x70, 0x72, 0x5f, 0x6c, 0x69, 0x74,  // ··kind··expr_lit
    0x65, 0x72, 0x61, 0x6c, 0x0a, 0x84, 0x74, 0x79, 0x70, 0x65, 0x0a, 0x86, 0x53, 0x74, 0x72, 0x69,  // eral··type··Stri
    0x6e, 0x67, 0x0a, 0x85, 0x63, 0x6f, 0x6e, 0x73, 0x74, 0x0a, 0x84, 0x4f, 0x4b, 0x3a, 0x20, 0x0a,  // ng··const··OK: ·
    0x84, 0x77, 0x69, 0x74, 0x68, 0x07, 0xab, 0x83, 0x0a, 0x84, 0x6b, 0x69, 0x6e, 0x64, 0x0a, 0x8c,  // ·with·«···kind··
    0x65, 0x78, 0x70, 0x72, 0x5f, 0x6c, 0x69, 0x74, 0x65, 0x72, 0x61, 0x6c, 0x0a, 0x84, 0x74, 0x79,  // expr_literal··ty
    0x70, 0x65, 0x0a, 0x86, 0x4f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x0a, 0x85, 0x63, 0x6f, 0x6e, 0x73,  // pe··Object··cons
    0x74, 0x03, 0x0a, 0x88, 0x62, 0x65, 0x68, 0x61, 0x76, 0x69, 0x6f, 0x72, 0x07, 0x10, 0x82, 0xc1,  // t···behavior···Á
    0x01, 0x83, 0x0a, 0x84, 0x6b, 0x69, 0x6e, 0x64, 0x0a, 0x8e, 0x61, 0x63, 0x74, 0x6f, 0x72, 0x5f,  // ····kind··actor_
    0x62, 0x65, 0x68, 0x61, 0x76, 0x69, 0x6f, 0x72, 0x0a, 0x84, 0x6e, 0x61, 0x6d, 0x65, 0x0f, 0x0a,  // behavior··name··
    0x86, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x06, 0x10, 0x82, 0x96, 0x01, 0x82, 0x07, 0x10, 0x82,  // ·script·········
    0xc0, 0x00, 0x83, 0x0a, 0x84, 0x6b, 0x69, 0x6e, 0x64, 0x0a, 0x8c, 0x61, 0x63, 0x74, 0x6f, 0x72,  // À····kind··actor
    0x5f, 0x61, 0x73, 0x73, 0x69, 0x67, 0x6e, 0x0a, 0x84, 0x6e, 0x61, 0x6d, 0x65, 0x0a, 0x87, 0x6d,  // _assign··name··m
    0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x0a, 0x85, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x07, 0x10, 0x82,  // essage··value···
    0x90, 0x00, 0x83, 0x0a, 0x84, 0x6b, 0x69, 0x6e, 0x64, 0x0a, 0x8e, 0x65, 0x78, 0x70, 0x72, 0x5f,  // ·····kind··expr_
    0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x0a, 0x84, 0x6e, 0x61, 0x6d, 0x65, 0x0a,  // operation··name·
    0x87, 0x6a, 0x6f, 0x69, 0x6e, 0x5b, 0x2a, 0x5d, 0x0a, 0x84, 0x61, 0x72, 0x67, 0x73, 0x06, 0xe2,  // ·join[*]··args·â
    0x82, 0x07, 0xa1, 0x82, 0x0a, 0x84, 0x6b, 0x69, 0x6e, 0x64, 0x0a, 0x8b, 0x61, 0x63, 0x74, 0x6f,  // ··¡···kind··acto
    0x72, 0x5f, 0x73, 0x74, 0x61, 0x74, 0x65, 0x0a, 0x84, 0x6e, 0x61, 0x6d, 0x65, 0x0a, 0x85, 0x6c,  // r_state··name··l
    0x61, 0x62, 0x65, 0x6c, 0x07, 0xbc, 0x83, 0x0a, 0x84, 0x6b, 0x69, 0x6e, 0x64, 0x0a, 0x88, 0x64,  // abel·¼···kind··d
    0x69, 0x63, 0x74, 0x5f, 0x67, 0x65, 0x74, 0x0a, 0x84, 0x6e, 0x61, 0x6d, 0x65, 0x0a, 0x87, 0x6d,  // ict_get··name··m
    0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x0a, 0x82, 0x69, 0x6e, 0x07, 0x96, 0x81, 0x0a, 0x84, 0x6b,  // essage··in·····k
    0x69, 0x6e, 0x64, 0x0a, 0x8d, 0x61, 0x63, 0x74, 0x6f, 0x72, 0x5f, 0x6d, 0x65, 0x73, 0x73, 0x61,  // ind··actor_messa
    0x67, 0x65, 0x07, 0x10, 0x82, 0xcb, 0x00, 0x83, 0x0a, 0x84, 0x6b, 0x69, 0x6e, 0x64, 0x0a, 0x8a,  // ge···Ë····kind··
    0x61, 0x63, 0x74, 0x6f, 0x72, 0x5f, 0x73, 0x65, 0x6e, 0x64, 0x0a, 0x87, 0x6d, 0x65, 0x73, 0x73,  // actor_send··mess
    0x61, 0x67, 0x65, 0x07, 0x10, 0x82, 0x80, 0x00, 0x84, 0x0a, 0x84, 0x6b, 0x69, 0x6e, 0x64, 0x0a,  // age········kind·
    0x89, 0x64, 0x69, 0x63, 0x74, 0x5f, 0x62, 0x69, 0x6e, 0x64, 0x0a, 0x84, 0x6e, 0x61, 0x6d, 0x65,  // ·dict_bind··name
    0x0a, 0x87, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x0a, 0x85, 0x76, 0x61, 0x6c, 0x75, 0x65,  // ··message··value
    0x07, 0xa3, 0x82, 0x0a, 0x84, 0x6b, 0x69, 0x6e, 0x64, 0x0a, 0x8b, 0x61, 0x63, 0x74, 0x6f, 0x72,  // ·£···kind··actor
    0x5f, 0x73, 0x74, 0x61, 0x74, 0x65, 0x0a, 0x84, 0x6e, 0x61, 0x6d, 0x65, 0x0a, 0x87, 0x6d, 0x65,  // _state··name··me
    0x73, 0x73, 0x61, 0x67, 0x65, 0x0a, 0x84, 0x77, 0x69, 0x74, 0x68, 0x07, 0xab, 0x83, 0x0a, 0x84,  // ssage··with·«···
    0x6b, 0x69, 0x6e, 0x64, 0x0a, 0x8c, 0x65, 0x78, 0x70, 0x72, 0x5f, 0x6c, 0x69, 0x74, 0x65, 0x72,  // kind··expr_liter
    0x61, 0x6c, 0x0a, 0x84, 0x74, 0x79, 0x70, 0x65, 0x0a, 0x86, 0x4f, 0x62, 0x6a, 0x65, 0x63, 0x74,  // al··type··Object
    0x0a, 0x85, 0x63, 0x6f, 0x6e, 0x73, 0x74, 0x03, 0x0a, 0x85, 0x61, 0x63, 0x74, 0x6f, 0x72, 0x07,  // ··const···actor·
    0xa1, 0x82, 0x0a, 0x84, 0x6b, 0x69, 0x6e, 0x64, 0x0a, 0x8b, 0x61, 0x63, 0x74, 0x6f, 0x72, 0x5f,  // ¡···kind··actor_
    0x73, 0x74, 0x61, 0x74, 0x65, 0x0a, 0x84, 0x6e, 0x61, 0x6d, 0x65, 0x0a, 0x85, 0x61, 0x6c, 0x65,  // state··name··ale
    0x72, 0x74, 0x07, 0x10, 0x82, 0xd6, 0x00, 0x83, 0x0a, 0x84, 0x6b, 0x69, 0x6e, 0x64, 0x0a, 0x8a,  // rt···Ö····kind··
    0x61, 0x63, 0x74, 0x6f, 0x72, 0x5f, 0x73, 0x65, 0x6e, 0x64, 0x0a, 0x87, 0x6d, 0x65, 0x73, 0x73,  // actor_send··mess
    0x61, 0x67, 0x65, 0x07, 0x10, 0x82, 0x8e, 0x00, 0x84, 0x0a, 0x84, 0x6b, 0x69, 0x6e, 0x64, 0x0a,  // age········kind·
    0x89, 0x64, 0x69, 0x63, 0x74, 0x5f, 0x62, 0x69, 0x6e, 0x64, 0x0a, 0x84, 0x6e, 0x61, 0x6d, 0x65,  // ·dict_bind··name
    0x0a, 0x87, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x0a, 0x85, 0x76, 0x61, 0x6c, 0x75, 0x65,  // ··message··value
    0x07, 0xb1, 0x83, 0x0a, 0x84, 0x6b, 0x69, 0x6e, 0x64, 0x0a, 0x8c, 0x65, 0x78, 0x70, 0x72, 0x5f,  // ·±···kind··expr_
    0x6c, 0x69, 0x74, 0x65, 0x72, 0x61, 0x6c, 0x0a, 0x84, 0x74, 0x79, 0x70, 0x65, 0x0a, 0x86, 0x53,  // literal··type··S
    0x74, 0x72, 0x69, 0x6e, 0x67, 0x0a, 0x85, 0x63, 0x6f, 0x6e, 0x73, 0x74, 0x0a, 0x85, 0x68, 0x65,  // tring··const··he
    0x6c, 0x6c, 0x6f, 0x0a, 0x84, 0x77, 0x69, 0x74, 0x68, 0x07, 0xab, 0x83, 0x0a, 0x84, 0x6b, 0x69,  // llo··with·«···ki
    0x6e, 0x64, 0x0a, 0x8c, 0x65, 0x78, 0x70, 0x72, 0x5f, 0x6c, 0x69, 0x74, 0x65, 0x72, 0x61, 0x6c,  // nd··expr_literal
    0x0a, 0x84, 0x74, 0x79, 0x70, 0x65, 0x0a, 0x86, 0x4f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x0a, 0x85,  // ··type··Object··
    0x63, 0x6f, 0x6e, 0x73, 0x74, 0x03, 0x0a, 0x85, 0x61, 0x63, 0x74, 0x6f, 0x72, 0x07, 0x9e, 0x82,  // const···actor···
    0x0a, 0x84, 0x6b, 0x69, 0x6e, 0x64, 0x0a, 0x8b, 0x61, 0x63, 0x74, 0x6f, 0x72, 0x5f, 0x73, 0x74,  // ··kind··actor_st
    0x61, 0x74, 0x65, 0x0a, 0x84, 0x6e, 0x61, 0x6d, 0x65, 0x0a, 0x82, 0x6f, 0x6b,                    // ate··name··ok
};
*/
/**/
BYTE bootstrap[] = {  // stateless stream reader (from PEG example)
    0x06, 0x10, 0x82, 0xb0, 0x05, 0x81, 0x07, 0x10, 0x82, 0xaa, 0x05, 0x84, 0x0b, 0x84, 0x6b, 0x69,  // ···°·····ª····ki
    0x6e, 0x64, 0x0b, 0x8d, 0x61, 0x63, 0x74, 0x6f, 0x72, 0x5f, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x6f,  // nd··actor_sponso
    0x72, 0x0b, 0x86, 0x61, 0x63, 0x74, 0x6f, 0x72, 0x73, 0x89, 0x0b, 0x86, 0x65, 0x76, 0x65, 0x6e,  // r··actors···even
    0x74, 0x73, 0xe3, 0x0b, 0x86, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x06, 0x10, 0x82, 0x75, 0x05,  // tsã··script···u·
    0x86, 0x07, 0x10, 0x82, 0xc2, 0x00, 0x83, 0x09, 0x00, 0x0b, 0x8c, 0x61, 0x63, 0x74, 0x6f, 0x72,  // ····Â······actor
    0x5f, 0x61, 0x73, 0x73, 0x69, 0x67, 0x6e, 0x0b, 0x84, 0x6e, 0x61, 0x6d, 0x65, 0x0b, 0x87, 0x63,  // _assign··name··c
    0x6f, 0x6e, 0x73, 0x6f, 0x6c, 0x65, 0x0b, 0x85, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x07, 0x10, 0x82,  // onsole··value···
    0x96, 0x00, 0x83, 0x09, 0x00, 0x0b, 0x8c, 0x61, 0x63, 0x74, 0x6f, 0x72, 0x5f, 0x63, 0x72, 0x65,  // ·······actor_cre
    0x61, 0x74, 0x65, 0x0b, 0x85, 0x73, 0x74, 0x61, 0x74, 0x65, 0x07, 0xa7, 0x83, 0x09, 0x00, 0x0b,  // ate··state·§····
    0x8c, 0x65, 0x78, 0x70, 0x72, 0x5f, 0x6c, 0x69, 0x74, 0x65, 0x72, 0x61, 0x6c, 0x0b, 0x84, 0x74,  // ·expr_literal··t
    0x79, 0x70, 0x65, 0x0b, 0x86, 0x4f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x0b, 0x85, 0x63, 0x6f, 0x6e,  // ype··Object··con
    0x73, 0x74, 0x03, 0x0b, 0x88, 0x62, 0x65, 0x68, 0x61, 0x76, 0x69, 0x6f, 0x72, 0x07, 0xc9, 0x83,  // st···behavior·É·
    0x09, 0x00, 0x0b, 0x8e, 0x61, 0x63, 0x74, 0x6f, 0x72, 0x5f, 0x62, 0x65, 0x68, 0x61, 0x76, 0x69,  // ····actor_behavi
    0x6f, 0x72, 0x09, 0x06, 0x0f, 0x09, 0x04, 0x06, 0xaf, 0x81, 0x07, 0xac, 0x83, 0x09, 0x00, 0x0b,  // or······¯··¬····
    0x89, 0x6c, 0x6f, 0x67, 0x5f, 0x70, 0x72, 0x69, 0x6e, 0x74, 0x0b, 0x85, 0x6c, 0x65, 0x76, 0x65,  // ·log_print··leve
    0x6c, 0x81, 0x09, 0x08, 0x07, 0x92, 0x81, 0x09, 0x00, 0x0b, 0x8d, 0x61, 0x63, 0x74, 0x6f, 0x72,  // l··········actor
    0x5f, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x07, 0x10, 0x82, 0x84, 0x00, 0x83, 0x09, 0x00,  // _message········
    0x09, 0x05, 0x09, 0x06, 0x0b, 0x8b, 0x62, 0x6f, 0x75, 0x6e, 0x64, 0x5f, 0x76, 0x61, 0x6c, 0x75,  // ······bound_valu
    0x65, 0x09, 0x08, 0x07, 0xec, 0x83, 0x09, 0x00, 0x09, 0x10, 0x09, 0x06, 0x09, 0x14, 0x09, 0x04,  // e···ì···········
    0x06, 0xdf, 0x81, 0x07, 0xdc, 0x83, 0x09, 0x00, 0x0b, 0x8a, 0x61, 0x63, 0x74, 0x6f, 0x72, 0x5f,  // ·ß··Ü·····actor_
    0x73, 0x65, 0x6e, 0x64, 0x0b, 0x87, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x07, 0x99, 0x82,  // send··message···
    0x09, 0x00, 0x0b, 0x8b, 0x61, 0x63, 0x74, 0x6f, 0x72, 0x5f, 0x73, 0x74, 0x61, 0x74, 0x65, 0x09,  // ····actor_state·
    0x06, 0x0b, 0x85, 0x72, 0x65, 0x70, 0x6c, 0x79, 0x0b, 0x85, 0x61, 0x63, 0x74, 0x6f, 0x72, 0x07,  // ···reply··actor·
    0xa0, 0x83, 0x09, 0x00, 0x0b, 0x88, 0x64, 0x69, 0x63, 0x74, 0x5f, 0x67, 0x65, 0x74, 0x09, 0x06,  //  ·····dict_get··
    0x0b, 0x84, 0x63, 0x75, 0x73, 0x74, 0x0b, 0x82, 0x69, 0x6e, 0x07, 0x85, 0x81, 0x09, 0x00, 0x09,  // ··cust··in······
    0x13, 0x07, 0x10, 0x82, 0x86, 0x02, 0x83, 0x09, 0x00, 0x09, 0x05, 0x09, 0x06, 0x0b, 0x8b, 0x74,  // ···············t
    0x65, 0x78, 0x74, 0x5f, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x09, 0x08, 0x07, 0x10, 0x82, 0x6b,  // ext_stream·····k
    0x02, 0x83, 0x09, 0x00, 0x09, 0x10, 0x09, 0x06, 0x0b, 0x90, 0x73, 0x74, 0x61, 0x74, 0x65, 0x6c,  // ··········statel
    0x65, 0x73, 0x73, 0x5f, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x09, 0x04, 0x06, 0x10, 0x82, 0x4b,  // ess_stream·····K
    0x02, 0x84, 0x07, 0x99, 0x83, 0x09, 0x00, 0x09, 0x05, 0x09, 0x06, 0x09, 0x18, 0x09, 0x08, 0x07,  // ················
    0x8c, 0x83, 0x09, 0x00, 0x09, 0x0b, 0x09, 0x0c, 0x09, 0x0d, 0x09, 0x0e, 0x03, 0x07, 0x10, 0x82,  // ················
    0xe7, 0x01, 0x82, 0x09, 0x00, 0x0b, 0x8b, 0x63, 0x6f, 0x6e, 0x64, 0x69, 0x74, 0x69, 0x6f, 0x6e,  // ç······condition
    0x61, 0x6c, 0x0b, 0x84, 0x61, 0x72, 0x67, 0x73, 0x06, 0x10, 0x82, 0xcc, 0x01, 0x81, 0x07, 0x10,  // al··args···Ì····
    0x82, 0xc6, 0x01, 0x82, 0x0b, 0x82, 0x69, 0x66, 0x07, 0xef, 0x84, 0x09, 0x00, 0x0b, 0x8e, 0x65,  // ·Æ····if·ï·····e
    0x78, 0x70, 0x72, 0x5f, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x09, 0x0c, 0x0b,  // xpr_operation···
    0x87, 0x42, 0x6f, 0x6f, 0x6c, 0x65, 0x61, 0x6e, 0x09, 0x06, 0x0b, 0x86, 0x4c, 0x54, 0x45, 0x5b,  // ·Boolean····LTE[
    0x32, 0x5d, 0x09, 0x20, 0x06, 0xc3, 0x82, 0x07, 0x8e, 0x82, 0x09, 0x00, 0x09, 0x17, 0x09, 0x06,  // 2]· ·Ã··········
    0x0b, 0x85, 0x69, 0x6e, 0x64, 0x65, 0x78, 0x07, 0xb0, 0x84, 0x09, 0x00, 0x09, 0x22, 0x09, 0x0c,  // ··index·°····"··
    0x0b, 0x86, 0x4e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x09, 0x06, 0x0b, 0x89, 0x6c, 0x65, 0x6e, 0x67,  // ··Number····leng
    0x74, 0x68, 0x5b, 0x31, 0x5d, 0x09, 0x20, 0x06, 0x90, 0x81, 0x07, 0x8d, 0x82, 0x09, 0x00, 0x09,  // th[1]· ·········
    0x17, 0x09, 0x06, 0x0b, 0x84, 0x74, 0x65, 0x78, 0x74, 0x0b, 0x82, 0x64, 0x6f, 0x06, 0x10, 0x82,  // ·····text··do···
    0x47, 0x01, 0x82, 0x07, 0x10, 0x82, 0x9f, 0x00, 0x83, 0x09, 0x00, 0x09, 0x05, 0x09, 0x06, 0x0b,  // G···············
    0x84, 0x6e, 0x65, 0x78, 0x74, 0x09, 0x08, 0x07, 0x10, 0x82, 0x8b, 0x00, 0x83, 0x09, 0x00, 0x09,  // ·next···········
    0x09, 0x09, 0x0a, 0x07, 0xf5, 0x84, 0x09, 0x00, 0x0b, 0x89, 0x64, 0x69, 0x63, 0x74, 0x5f, 0x62,  // ····õ·····dict_b
    0x69, 0x6e, 0x64, 0x09, 0x06, 0x09, 0x28, 0x09, 0x08, 0x07, 0x89, 0x82, 0x09, 0x00, 0x09, 0x17,  // ind···(·········
    0x09, 0x06, 0x09, 0x28, 0x0b, 0x84, 0x77, 0x69, 0x74, 0x68, 0x07, 0xce, 0x84, 0x09, 0x00, 0x09,  // ···(··with·Î····
    0x2b, 0x09, 0x06, 0x09, 0x25, 0x09, 0x08, 0x07, 0xb1, 0x84, 0x09, 0x00, 0x09, 0x22, 0x09, 0x0c,  // +···%···±····"··
    0x09, 0x26, 0x09, 0x06, 0x0b, 0x86, 0x41, 0x44, 0x44, 0x5b, 0x32, 0x5d, 0x09, 0x20, 0x06, 0x9a,  // ·&····ADD[2]· ··
    0x82, 0x07, 0x89, 0x82, 0x09, 0x00, 0x09, 0x17, 0x09, 0x06, 0x09, 0x25, 0x07, 0x8c, 0x83, 0x09,  // ···········%····
    0x00, 0x09, 0x0b, 0x09, 0x0c, 0x09, 0x26, 0x09, 0x0e, 0x81, 0x09, 0x2c, 0x07, 0x8c, 0x83, 0x09,  // ······&····,····
    0x00, 0x09, 0x0b, 0x09, 0x0c, 0x09, 0x0d, 0x09, 0x0e, 0x03, 0x09, 0x0f, 0x07, 0x89, 0x82, 0x09,  // ················
    0x00, 0x09, 0x17, 0x09, 0x06, 0x09, 0x1d, 0x07, 0x10, 0x82, 0x9d, 0x00, 0x83, 0x09, 0x00, 0x09,  // ················
    0x05, 0x09, 0x06, 0x09, 0x18, 0x09, 0x08, 0x07, 0x10, 0x82, 0x8d, 0x00, 0x84, 0x09, 0x00, 0x09,  // ················
    0x2b, 0x09, 0x06, 0x09, 0x08, 0x09, 0x08, 0x07, 0xbc, 0x84, 0x09, 0x00, 0x09, 0x22, 0x09, 0x0c,  // +·······¼····"··
    0x09, 0x26, 0x09, 0x06, 0x0b, 0x94, 0x63, 0x68, 0x61, 0x72, 0x41, 0x74, 0x5f, 0x46, 0x52, 0x4f,  // ·&····charAt_FRO
    0x4d, 0x5f, 0x53, 0x54, 0x41, 0x52, 0x54, 0x5b, 0x32, 0x5d, 0x09, 0x20, 0x06, 0x97, 0x82, 0x07,  // M_START[2]· ····
    0x89, 0x82, 0x09, 0x00, 0x09, 0x17, 0x09, 0x06, 0x09, 0x28, 0x07, 0x89, 0x82, 0x09, 0x00, 0x09,  // ·········(······
    0x17, 0x09, 0x06, 0x09, 0x25, 0x09, 0x2c, 0x07, 0xc0, 0x84, 0x09, 0x00, 0x09, 0x2b, 0x09, 0x06,  // ····%·,·À····+··
    0x09, 0x2a, 0x09, 0x08, 0x07, 0x89, 0x82, 0x09, 0x00, 0x09, 0x17, 0x09, 0x06, 0x09, 0x2a, 0x09,  // ·*············*·
    0x2c, 0x07, 0xa6, 0x84, 0x09, 0x00, 0x09, 0x2b, 0x09, 0x06, 0x09, 0x25, 0x09, 0x08, 0x07, 0x89,  // ,·¦····+···%····
    0x82, 0x09, 0x00, 0x09, 0x17, 0x09, 0x06, 0x09, 0x25, 0x09, 0x2c, 0x07, 0x8c, 0x83, 0x09, 0x00,  // ········%·,·····
    0x09, 0x0b, 0x09, 0x0c, 0x09, 0x0d, 0x09, 0x0e, 0x03, 0x07, 0x9e, 0x82, 0x09, 0x00, 0x0b, 0x8c,  // ················
    0x61, 0x63, 0x74, 0x6f, 0x72, 0x5f, 0x62, 0x65, 0x63, 0x6f, 0x6d, 0x65, 0x09, 0x0f, 0x07, 0x89,  // actor_become····
    0x82, 0x09, 0x00, 0x09, 0x17, 0x09, 0x06, 0x09, 0x14, 0x07, 0xa1, 0x83, 0x09, 0x00, 0x09, 0x15,  // ··········¡·····
    0x09, 0x16, 0x07, 0x85, 0x81, 0x09, 0x00, 0x09, 0x13, 0x09, 0x19, 0x07, 0x8f, 0x81, 0x09, 0x00,  // ················
    0x0b, 0x8a, 0x61, 0x63, 0x74, 0x6f, 0x72, 0x5f, 0x73, 0x65, 0x6c, 0x66, 0x07, 0xfa, 0x83, 0x09,  // ··actor_self·ú··
    0x00, 0x09, 0x05, 0x09, 0x06, 0x0b, 0x86, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x09, 0x08, 0x07,  // ·······stream···
    0xe7, 0x83, 0x09, 0x00, 0x09, 0x09, 0x09, 0x0a, 0x07, 0xd1, 0x84, 0x09, 0x00, 0x09, 0x2b, 0x09,  // ç········Ñ····+·
    0x06, 0x09, 0x28, 0x09, 0x08, 0x07, 0x97, 0x83, 0x09, 0x00, 0x09, 0x0b, 0x09, 0x0c, 0x0b, 0x86,  // ··(·············
    0x53, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x09, 0x0e, 0x0a, 0x84, 0x31, 0x33, 0x2f, 0x38, 0x09, 0x2c,  // String····13/8·,
    0x07, 0xa9, 0x84, 0x09, 0x00, 0x09, 0x2b, 0x09, 0x06, 0x09, 0x25, 0x09, 0x08, 0x07, 0x8c, 0x83,  // ·©····+···%·····
    0x09, 0x00, 0x09, 0x0b, 0x09, 0x0c, 0x09, 0x26, 0x09, 0x0e, 0x81, 0x09, 0x2c, 0x07, 0x8c, 0x83,  // ·······&····,···
    0x09, 0x00, 0x09, 0x0b, 0x09, 0x0c, 0x09, 0x0d, 0x09, 0x0e, 0x03, 0x09, 0x0f, 0x07, 0x89, 0x82,  // ················
    0x09, 0x00, 0x09, 0x17, 0x09, 0x06, 0x09, 0x1d, 0x07, 0x10, 0x82, 0xda, 0x00, 0x83, 0x09, 0x00,  // ···········Ú····
    0x09, 0x05, 0x09, 0x06, 0x0b, 0x86, 0x72, 0x65, 0x61, 0x64, 0x65, 0x72, 0x09, 0x08, 0x07, 0x10,  // ······reader····
    0x82, 0xc4, 0x00, 0x83, 0x09, 0x00, 0x09, 0x09, 0x09, 0x0a, 0x07, 0x8c, 0x83, 0x09, 0x00, 0x09,  // ·Ä··············
    0x0b, 0x09, 0x0c, 0x09, 0x0d, 0x09, 0x0e, 0x03, 0x09, 0x0f, 0x07, 0x10, 0x82, 0xa8, 0x00, 0x83,  // ·············¨··
    0x09, 0x00, 0x09, 0x10, 0x09, 0x06, 0x0b, 0x8d, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x5f, 0x72,  // ········stream_r
    0x65, 0x61, 0x64, 0x65, 0x72, 0x09, 0x04, 0x06, 0x10, 0x82, 0x8b, 0x00, 0x82, 0x07, 0x9b, 0x83,  // eader···········
    0x09, 0x00, 0x09, 0x15, 0x09, 0x16, 0x07, 0x85, 0x81, 0x09, 0x00, 0x09, 0x13, 0x09, 0x19, 0x07,  // ················
    0x89, 0x82, 0x09, 0x00, 0x09, 0x17, 0x09, 0x06, 0x09, 0x07, 0x07, 0xeb, 0x82, 0x09, 0x00, 0x09,  // ···········ë····
    0x1f, 0x09, 0x20, 0x06, 0xe2, 0x81, 0x07, 0xdf, 0x82, 0x09, 0x21, 0x07, 0x92, 0x83, 0x09, 0x00,  // ·· ·â··ß··!·····
    0x09, 0x1a, 0x09, 0x06, 0x09, 0x2a, 0x09, 0x1c, 0x07, 0x85, 0x81, 0x09, 0x00, 0x09, 0x13, 0x09,  // ·····*··········
    0x29, 0x06, 0xc4, 0x81, 0x07, 0xc1, 0x83, 0x09, 0x00, 0x09, 0x15, 0x09, 0x16, 0x07, 0xa2, 0x84,  // )·Ä··Á········¢·
    0x09, 0x00, 0x09, 0x2b, 0x09, 0x06, 0x09, 0x1b, 0x09, 0x08, 0x07, 0x85, 0x81, 0x09, 0x00, 0x09,  // ···+············
    0x30, 0x09, 0x2c, 0x07, 0x8c, 0x83, 0x09, 0x00, 0x09, 0x0b, 0x09, 0x0c, 0x09, 0x0d, 0x09, 0x0e,  // 0·,·············
    0x03, 0x09, 0x19, 0x07, 0x92, 0x83, 0x09, 0x00, 0x09, 0x1a, 0x09, 0x06, 0x09, 0x2a, 0x09, 0x1c,  // ·············*··
    0x07, 0x85, 0x81, 0x09, 0x00, 0x09, 0x13, 0x07, 0xbc, 0x83, 0x09, 0x00, 0x09, 0x15, 0x09, 0x16,  // ········¼·······
    0x07, 0xa6, 0x84, 0x09, 0x00, 0x09, 0x2b, 0x09, 0x06, 0x09, 0x1b, 0x09, 0x08, 0x07, 0x89, 0x82,  // ·¦····+·········
    0x09, 0x00, 0x09, 0x17, 0x09, 0x06, 0x09, 0x33, 0x09, 0x2c, 0x07, 0x8c, 0x83, 0x09, 0x00, 0x09,  // ·······3·,······
    0x0b, 0x09, 0x0c, 0x09, 0x0d, 0x09, 0x0e, 0x03, 0x09, 0x19, 0x07, 0x89, 0x82, 0x09, 0x00, 0x09,  // ················
    0x17, 0x09, 0x06, 0x09, 0x31,                                                                    // ····1
};
/*
BYTE bootstrap[] = {  // testcase for FAIL! action
    0x06, 0x10, 0x82, 0x7a, 0x02, 0x81, 0x07, 0x10, 0x82, 0x74, 0x02, 0x84, 0x0b, 0x84, 0x6b, 0x69,  // ···z·····t····ki
    0x6e, 0x64, 0x0b, 0x8d, 0x61, 0x63, 0x74, 0x6f, 0x72, 0x5f, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x6f,  // nd··actor_sponso
    0x72, 0x0b, 0x86, 0x61, 0x63, 0x74, 0x6f, 0x72, 0x73, 0x81, 0x0b, 0x86, 0x65, 0x76, 0x65, 0x6e,  // r··actors···even
    0x74, 0x73, 0x83, 0x0b, 0x86, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x06, 0x10, 0x82, 0x3f, 0x02,  // ts···script···?·
    0x81, 0x07, 0x10, 0x82, 0x39, 0x02, 0x83, 0x09, 0x00, 0x0b, 0x8a, 0x61, 0x63, 0x74, 0x6f, 0x72,  // ····9······actor
    0x5f, 0x73, 0x65, 0x6e, 0x64, 0x0b, 0x87, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x07, 0xa7,  // _send··message·§
    0x83, 0x09, 0x00, 0x0b, 0x8c, 0x65, 0x78, 0x70, 0x72, 0x5f, 0x6c, 0x69, 0x74, 0x65, 0x72, 0x61,  // ·····expr_litera
    0x6c, 0x0b, 0x84, 0x74, 0x79, 0x70, 0x65, 0x0b, 0x86, 0x4f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x0b,  // l··type··Object·
    0x85, 0x63, 0x6f, 0x6e, 0x73, 0x74, 0x03, 0x0b, 0x85, 0x61, 0x63, 0x74, 0x6f, 0x72, 0x07, 0x10,  // ·const···actor··
    0x82, 0xec, 0x01, 0x83, 0x09, 0x00, 0x0b, 0x8c, 0x61, 0x63, 0x74, 0x6f, 0x72, 0x5f, 0x63, 0x72,  // ·ì······actor_cr
    0x65, 0x61, 0x74, 0x65, 0x0b, 0x85, 0x73, 0x74, 0x61, 0x74, 0x65, 0x07, 0xca, 0x84, 0x09, 0x00,  // eate··state·Ê···
    0x0b, 0x89, 0x64, 0x69, 0x63, 0x74, 0x5f, 0x62, 0x69, 0x6e, 0x64, 0x0b, 0x84, 0x6e, 0x61, 0x6d,  // ··dict_bind··nam
    0x65, 0x0b, 0x85, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x0b, 0x85, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x07,  // e··count··value·
    0x92, 0x83, 0x09, 0x00, 0x09, 0x07, 0x09, 0x08, 0x0b, 0x86, 0x4e, 0x75, 0x6d, 0x62, 0x65, 0x72,  // ··········Number
    0x09, 0x0a, 0x80, 0x0b, 0x84, 0x77, 0x69, 0x74, 0x68, 0x07, 0x8c, 0x83, 0x09, 0x00, 0x09, 0x07,  // ·····with·······
    0x09, 0x08, 0x09, 0x09, 0x09, 0x0a, 0x03, 0x0b, 0x88, 0x62, 0x65, 0x68, 0x61, 0x76, 0x69, 0x6f,  // ·········behavio
    0x72, 0x07, 0x10, 0x82, 0x79, 0x01, 0x83, 0x09, 0x00, 0x0b, 0x8e, 0x61, 0x63, 0x74, 0x6f, 0x72,  // r···y······actor
    0x5f, 0x62, 0x65, 0x68, 0x61, 0x76, 0x69, 0x6f, 0x72, 0x09, 0x0f, 0x0f, 0x09, 0x04, 0x06, 0x10,  // _behavior·······
    0x82, 0x5c, 0x01, 0x86, 0x07, 0xe7, 0x83, 0x09, 0x00, 0x0b, 0x8c, 0x61, 0x63, 0x74, 0x6f, 0x72,  // ·\···ç·····actor
    0x5f, 0x61, 0x73, 0x73, 0x69, 0x67, 0x6e, 0x09, 0x0f, 0x09, 0x10, 0x09, 0x11, 0x07, 0xce, 0x84,  // _assign·······Î·
    0x09, 0x00, 0x0b, 0x8e, 0x65, 0x78, 0x70, 0x72, 0x5f, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69,  // ····expr_operati
    0x6f, 0x6e, 0x09, 0x08, 0x09, 0x12, 0x09, 0x0f, 0x0b, 0x86, 0x41, 0x44, 0x44, 0x5b, 0x32, 0x5d,  // on········ADD[2]
    0x0b, 0x84, 0x61, 0x72, 0x67, 0x73, 0x06, 0xa5, 0x82, 0x07, 0x94, 0x82, 0x09, 0x00, 0x0b, 0x8b,  // ··args·¥········
    0x61, 0x63, 0x74, 0x6f, 0x72, 0x5f, 0x73, 0x74, 0x61, 0x74, 0x65, 0x09, 0x0f, 0x09, 0x10, 0x07,  // actor_state·····
    0x8c, 0x83, 0x09, 0x00, 0x09, 0x07, 0x09, 0x08, 0x09, 0x12, 0x09, 0x0a, 0x81, 0x07, 0xa3, 0x83,  // ··············£·
    0x09, 0x00, 0x0b, 0x89, 0x6c, 0x6f, 0x67, 0x5f, 0x70, 0x72, 0x69, 0x6e, 0x74, 0x0b, 0x85, 0x6c,  // ····log_print··l
    0x65, 0x76, 0x65, 0x6c, 0x81, 0x09, 0x11, 0x07, 0x89, 0x82, 0x09, 0x00, 0x09, 0x1a, 0x09, 0x0f,  // evel············
    0x09, 0x10, 0x07, 0xa8, 0x83, 0x09, 0x00, 0x09, 0x05, 0x09, 0x06, 0x07, 0x8c, 0x83, 0x09, 0x00,  // ···¨············
    0x09, 0x07, 0x09, 0x08, 0x09, 0x09, 0x09, 0x0a, 0x03, 0x09, 0x0b, 0x07, 0x8f, 0x81, 0x09, 0x00,  // ················
    0x0b, 0x8a, 0x61, 0x63, 0x74, 0x6f, 0x72, 0x5f, 0x73, 0x65, 0x6c, 0x66, 0x07, 0xcd, 0x82, 0x09,  // ··actor_self·Í··
    0x00, 0x0b, 0x8c, 0x61, 0x63, 0x74, 0x6f, 0x72, 0x5f, 0x62, 0x65, 0x63, 0x6f, 0x6d, 0x65, 0x09,  // ···actor_become·
    0x14, 0x07, 0xb8, 0x83, 0x09, 0x00, 0x09, 0x15, 0x09, 0x0f, 0x0f, 0x09, 0x04, 0x06, 0xac, 0x81,  // ··¸···········¬·
    0x07, 0xa9, 0x83, 0x09, 0x00, 0x09, 0x1b, 0x09, 0x1c, 0x81, 0x09, 0x11, 0x07, 0x9d, 0x83, 0x09,  // ·©··············
    0x00, 0x09, 0x07, 0x09, 0x08, 0x0b, 0x86, 0x53, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x09, 0x0a, 0x0a,  // ·······String···
    0x8a, 0x49, 0x67, 0x6e, 0x6f, 0x72, 0x65, 0x64, 0x2e, 0x2e, 0x2e, 0x07, 0xac, 0x82, 0x09, 0x00,  // ·Ignored...·¬···
    0x0b, 0x8a, 0x61, 0x63, 0x74, 0x6f, 0x72, 0x5f, 0x66, 0x61, 0x69, 0x6c, 0x0b, 0x85, 0x65, 0x72,  // ··actor_fail··er
    0x72, 0x6f, 0x72, 0x07, 0x94, 0x83, 0x09, 0x00, 0x09, 0x07, 0x09, 0x08, 0x09, 0x1f, 0x09, 0x0a,  // ror·············
    0x0a, 0x87, 0x54, 0x68, 0x72, 0x6f, 0x77, 0x21, 0x3f, 0x07, 0xa4, 0x83, 0x09, 0x00, 0x09, 0x1b,  // ··Throw!?·¤·····
    0x09, 0x1c, 0x81, 0x09, 0x11, 0x07, 0x98, 0x83, 0x09, 0x00, 0x09, 0x07, 0x09, 0x08, 0x09, 0x1f,  // ················
    0x09, 0x0a, 0x0a, 0x8b, 0x57, 0x68, 0x65, 0x72, 0x65, 0x20, 0x61, 0x6d, 0x20, 0x49, 0x3f,        // ····Where am I?
};
*/

// evaluate expression found in named object property
static BYTE property_eval(sponsor_t * sponsor, event_t * event, DATA_PTR object, DATA_PTR name, DATA_PTR * value) {
    LOG_TRACE("property_eval: object =", (WORD)object);
    DATA_PTR expression;
    if (!object_get(object, name, &expression)) {
        LOG_DEBUG("property_eval: missing property", (WORD)name);
        return false;  // missing property
    }
    if (!actor_eval(sponsor, event, expression, value)) {
        LOG_WARN("property_eval: bad expression!", (WORD)expression);
        return false;  // evaluation failed!
    }
    return true;  // success!
}

// evaluate array of expressions
static BYTE array_eval(sponsor_t * sponsor, event_t * event, DATA_PTR exprs, DATA_PTR * result) {
    LOG_TRACE("array_eval: exprs", (WORD)exprs);
    WORD length;
    if (!array_length(exprs, &length)) return false;  // exprs array required!
    LOG_TRACE("array_eval: exprs.length", length);
    if (!COPY(result, a_)) return false;  // allocation failure!
    WORD i;
    for (i = 0; i < length; ++i) {
        DATA_PTR expression;
        if (!array_get(exprs, i, &expression)) return false;  // expression required!
        DATA_PTR value;
        if (!actor_eval(sponsor, event, expression, &value)) {
            LOG_WARN("array_eval: bad expression!", (WORD)expression);
            return false;  // evaluation failed!
        }
        DATA_PTR array;
        if (!array_add(sponsor, *result, value, i, &array)) return false;  // allocation failure!
        if (!RELEASE(result)) return false;  // reclamation failure!
        *result = TRACK(array);
    }
    return true;  // success!
}

// evaluate binary operator expression
static BYTE op_2_eval(sponsor_t * sponsor, event_t * event, DATA_PTR exprs, DATA_PTR * x, DATA_PTR * y) {
    WORD length;
    if (!array_length(exprs, &length)) return false;  // exprs array required!
    if (length != 2) return false;  // exprs array must have exactly 2 elements!
    DATA_PTR result;
    if (!array_eval(sponsor, event, exprs, &result)) return false;  // evaluation failed!
    if (!array_get(result, 0, x)) return false;  // x value required!
    if (!array_get(result, 1, y)) return false;  // y value required!
    return true;  // success!
}

BYTE op_list[] = { utf8, n_4, 'l', 'i', 's', 't' };
BYTE op_join[] = { utf8, n_7, 'j', 'o', 'i', 'n', '[', '*', ']' };
BYTE op_conditional[] = { utf8, n_14, 'c', 'o', 'n', 'd', 'i', 't', 'i', 'o', 'n', 'a', 'l', '[', '*', ']' };
BYTE op_EQ_2[] = { utf8, n_5, 'E', 'Q', '[', '2', ']' };
BYTE op_NEQ_2[] = { utf8, n_6, 'N', 'E', 'Q', '[', '2', ']' };
BYTE op_LT_2[] = { utf8, n_5, 'L', 'T', '[', '2', ']' };
BYTE op_LTE_2[] = { utf8, n_6, 'L', 'T', 'E', '[', '2', ']' };
BYTE op_GT_2[] = { utf8, n_5, 'G', 'T', '[', '2', ']' };
BYTE op_GTE_2[] = { utf8, n_6, 'G', 'T', 'E', '[', '2', ']' };

// evaluate operation expression
BYTE operation_eval(sponsor_t * sponsor, event_t * event, DATA_PTR name, DATA_PTR args, DATA_PTR * result) {
    LOG_TRACE("operation_eval: name", (WORD)name);
    LOG_TRACE("operation_eval: args", (WORD)args);
    if (value_equiv(name, op_list)) {
        if (!array_eval(sponsor, event, args, result)) return false;  // evaluation failed!
    } else if (value_equiv(name, op_join)) {
        if (!array_eval(sponsor, event, args, result)) return false;  // evaluation failed!
        // TODO: join the results into a single string...
    } else if (value_equiv(name, op_conditional)) {  // FIXME: "conditional" is a command, but it _could_ be an expression...
        WORD length;
        if (!array_length(args, &length)) return false;  // args array required!
        if ((length & 1) == 0) return false;  // args array must have an even number of elements!
        WORD i;
        for (i = 0; i < length; i += 2) {  // iterate over "if" conditions...
            DATA_PTR if_expr;
            if (!array_get(args, i, &if_expr)) return false;  // if_expr required!
            DATA_PTR value;
            if (!actor_eval(sponsor, event, if_expr, &value)) {
                LOG_WARN("operation_eval: bad if_expr!", (WORD)if_expr);
                return false;  // evaluation failed!
            }
            if (value_equiv(value, b_true)) {
                DATA_PTR do_expr;
                if (!array_get(args, i+1, &do_expr)) return false;  // do_expr required!
                if (!actor_eval(sponsor, event, do_expr, result)) {
                    LOG_WARN("operation_eval: bad do_expr!", (WORD)do_expr);
                    return false;  // evaluation failed!
                }
                return true;  // success! -- early exit matching clause.
            }
        }
        *result = v_null;  // default value if no matching clause...
    } else if (value_equiv(name, op_EQ_2)) {
        DATA_PTR x;
        DATA_PTR y;
        if (!op_2_eval(sponsor, event, args, &x, &y)) return false;  // bad args!
        *result = (value_equiv(x, y)) ? b_true : b_false;
    } else if (value_equiv(name, op_NEQ_2)) {
        DATA_PTR x;
        DATA_PTR y;
        if (!op_2_eval(sponsor, event, args, &x, &y)) return false;  // bad args!
        *result = (value_equiv(x, y)) ? b_false : b_true;
    } else if (value_equiv(name, op_LT_2)) {
        DATA_PTR x;
        DATA_PTR y;
        if (!op_2_eval(sponsor, event, args, &x, &y)) return false;  // bad args!
        WORD i;
        if (!value_integer(x, &i)) return false;  // number required!
        WORD j;
        if (!value_integer(y, &j)) return false;  // number required!
        *result = ((long)i < (long)j) ? b_true : b_false;  // FIXME: only works for signed `long`...
    } else if (value_equiv(name, op_LTE_2)) {
        DATA_PTR x;
        DATA_PTR y;
        if (!op_2_eval(sponsor, event, args, &x, &y)) return false;  // bad args!
        WORD i;
        if (!value_integer(x, &i)) return false;  // number required!
        WORD j;
        if (!value_integer(y, &j)) return false;  // number required!
        *result = ((long)i <= (long)j) ? b_true : b_false;  // FIXME: only works for signed `long`...
    } else if (value_equiv(name, op_GT_2)) {
        DATA_PTR x;
        DATA_PTR y;
        if (!op_2_eval(sponsor, event, args, &x, &y)) return false;  // bad args!
        WORD i;
        if (!value_integer(x, &i)) return false;  // number required!
        WORD j;
        if (!value_integer(y, &j)) return false;  // number required!
        *result = ((long)i > (long)j) ? b_true : b_false;  // FIXME: only works for signed `long`...
    } else if (value_equiv(name, op_GTE_2)) {
        DATA_PTR x;
        DATA_PTR y;
        if (!op_2_eval(sponsor, event, args, &x, &y)) return false;  // bad args!
        WORD i;
        if (!value_integer(x, &i)) return false;  // number required!
        WORD j;
        if (!value_integer(y, &j)) return false;  // number required!
        *result = ((long)i >= (long)j) ? b_true : b_false;  // FIXME: only works for signed `long`...
    } else {
        LOG_WARN("operation_eval: unknown 'name' of operation", (WORD)name);
        // FIXME: probably want to return `false` here and fail the script execution, but we just ignore it...
        *result = v_null;
    }
    return true;  // success!
}

// evaluate actor expression (expression -> value)
BYTE actor_eval(sponsor_t * sponsor, event_t * event, DATA_PTR expression, DATA_PTR * result) {
    LOG_TRACE("actor_eval: expression", (WORD)expression);
    prints("  ");
    if (!value_print(expression, 0)) return false;  // print failed!
    DATA_PTR kind;
    if (!object_get(expression, s_kind, &kind)) {
        LOG_WARN("actor_eval: missing 'kind' property", (WORD)expression);
        return false;  // missing property
    }
    if (value_equiv(kind, k_expr_literal)) {
        // { "kind":"expr_literal", "const":<value> }
        LOG_DEBUG("actor_eval: literal expression", (WORD)kind);
        DATA_PTR constant;
        if (!object_get(expression, s_const, &constant)) {
            LOG_DEBUG("actor_eval: missing 'const' property", (WORD)expression);
            return false;  // missing property
        }
        *result = constant;
    } else if (value_equiv(kind, k_expr_operation)) {
        // { "kind":"expr_operation", "name":<string>, "args":[<expression>, ...] }
        LOG_DEBUG("actor_eval: operation expression", (WORD)kind);
        DATA_PTR name;
        if (!object_get(expression, s_name, &name)) {
            LOG_DEBUG("actor_eval: missing 'name' property", (WORD)expression);
            return false;  // missing property
        }
        // FIXME: make sure `name` is a String...
        DATA_PTR args;
        if (!object_get(expression, s_args, &args)) {
            LOG_DEBUG("actor_eval: missing 'args' property", (WORD)expression);
            return false;  // missing property
        }
        // FIXME: make sure `args` is an Array...
        if (!operation_eval(sponsor, event, name, args, result)) return false;  // operation failed!
    } else if (value_equiv(kind, k_actor_has_state)) {
        // { "kind":"actor_has_state", "name":<string> }
        LOG_DEBUG("actor_eval: actor_has_state expression", (WORD)kind);
        DATA_PTR name;
        if (!object_get(expression, s_name, &name)) {
            LOG_DEBUG("actor_eval: missing 'name' property", (WORD)expression);
            return false;  // missing property
        }
        // FIXME: make sure `name` is a String...
        *result = b_false;  // default value is `false`
        if (event_has_binding(sponsor, event, name)) {
            *result = b_true;  // default value is `true`
        }
    } else if (value_equiv(kind, k_actor_state)) {
        // { "kind":"actor_state", "name":<string> }
        LOG_DEBUG("actor_eval: actor_state expression", (WORD)kind);
        DATA_PTR name;
        if (!object_get(expression, s_name, &name)) {
            LOG_DEBUG("actor_eval: missing 'name' property", (WORD)expression);
            return false;  // missing property
        }
        // FIXME: make sure `name` is a String...
        if (!event_lookup_binding(sponsor, event, name, result)) return false;  // lookup failed!
    } else if (value_equiv(kind, k_dict_has)) {
        // { "kind":"dict_has", "name":<string>, "in":<dictionary> }
        LOG_DEBUG("actor_eval: dict_has expression", (WORD)kind);
        DATA_PTR name;
        if (!object_get(expression, s_name, &name)) {
            LOG_DEBUG("actor_eval: missing 'name' property", (WORD)expression);
            return false;  // missing property
        }
        // FIXME: make sure `name` is a String...
        DATA_PTR dict;
        if (!property_eval(sponsor, event, expression, s_in, &dict)) return false;  // evaluation failed!
        // FIXME: make sure `dict` is an Object...
        *result = b_false;  // default value is `false`
        if (object_has(dict, name)) {
            *result = b_true;  // default value is `true`
        }
    } else if (value_equiv(kind, k_dict_get)) {
        // { "kind":"dict_get", "name":<string>, "in":<dictionary> }
        LOG_DEBUG("actor_eval: dict_get expression", (WORD)kind);
        DATA_PTR name;
        if (!object_get(expression, s_name, &name)) {
            LOG_DEBUG("actor_eval: missing 'name' property", (WORD)expression);
            return false;  // missing property
        }
        // FIXME: make sure `name` is a String...
        DATA_PTR dict;
        if (!property_eval(sponsor, event, expression, s_in, &dict)) return false;  // evaluation failed!
        // FIXME: make sure `dict` is an Object...
        *result = v_null;  // default value is `null`
        if (!object_get(dict, name, result)) {
            LOG_WARN("actor_eval: undefined variable!", (WORD)name);
            // FIXME: we may want to "throw" an exception here...
        }
    } else if (value_equiv(kind, k_dict_bind)) {
        // { "kind":"dict_bind", "name":<string>, "value":<expression>, "with":<dictionary> }
        LOG_DEBUG("actor_eval: dict_bind expression", (WORD)kind);
        DATA_PTR name;
        if (!object_get(expression, s_name, &name)) {
            LOG_DEBUG("actor_eval: missing 'name' property", (WORD)expression);
            return false;  // missing property
        }
        // FIXME: make sure `name` is a String...
        DATA_PTR value;
        if (!property_eval(sponsor, event, expression, s_value, &value)) return false;  // evaluation failed!
        DATA_PTR dict;
        if (!property_eval(sponsor, event, expression, s_with, &dict)) return false;  // evaluation failed!
        // FIXME: make sure `dict` is an Object...
        *result = v_null;  // default value is `null`
        if (!object_add(sponsor, dict, name, value, result)) return false;  // allocation failure!
    } else if (value_equiv(kind, k_actor_message)) {
        // { "kind":"actor_message" }
        LOG_DEBUG("actor_eval: actor_message expression", (WORD)kind);
        if (!event_lookup_message(sponsor, event, result)) return false;  // lookup failed!
    } else if (value_equiv(kind, k_actor_self)) {
        // { "kind":"actor_self" }
        LOG_DEBUG("actor_eval: actor_self expression", (WORD)kind);
        if (!event_lookup_actor(sponsor, event, result)) return false;  // lookup failed!
    } else if (value_equiv(kind, k_actor_create)) {
        // { "kind":"actor_create", "state":<dictionary>, "behavior":<behavior> }
        LOG_DEBUG("actor_eval: actor_create expression", (WORD)kind);
        DATA_PTR state;
        if (!property_eval(sponsor, event, expression, s_state, &state)) return false;  // evaluation failed!
        DATA_PTR behavior;
        if (!property_eval(sponsor, event, expression, s_behavior, &behavior)) return false;  // evaluation failed!
        DATA_PTR address;
        if (!sponsor_create(sponsor, event, state, behavior, &address)) {
            LOG_WARN("actor_eval: create failed!", (WORD)expression);
            return false;  // create failed!
        }
        *result = address;
    } else if (value_equiv(kind, k_actor_behavior)) {
        // { "kind":"actor_behavior", "name":<string>, "script":[<action>, ...] }
        LOG_DEBUG("actor_eval: actor_behavior expression", (WORD)kind);
        *result = expression;  // self-evaluating expression
    } else {
        LOG_WARN("actor_eval: unknown 'kind' of expression", (WORD)kind);
        // FIXME: probably want to return `false` here and fail the script execution, but we just ignore it...
        *result = v_null;
    }
    LOG_TRACE("actor_eval: result", (WORD)(*result));
    prints("  -> ");
    if (!value_print(*result, 0)) return false;  // print failed!
    return true;  // success!
}

// execute actor command (action -> effects)
BYTE actor_exec(sponsor_t * sponsor, event_t * event, DATA_PTR command) {
    LOG_TRACE("actor_exec: command", (WORD)command);
    if (!value_print(command, 1)) return false;  // print failed!
    DATA_PTR kind;
    if (!object_get(command, s_kind, &kind)) {
        LOG_WARN("actor_exec: missing 'kind' property", (WORD)command);
        return false;  // missing property
    }
    if (value_equiv(kind, k_actor_assign)) {
        // { "kind":"actor_assign", "name":<string>, "value":<expression> }
        LOG_DEBUG("actor_exec: assign action", (WORD)kind);
        DATA_PTR name;
        if (!object_get(command, s_name, &name)) {
            LOG_DEBUG("actor_exec: missing 'name' property", (WORD)command);
            return false;  // missing property
        }
        // FIXME: make sure `name` is a String...
        DATA_PTR value;
        if (!property_eval(sponsor, event, command, s_value, &value)) return false;  // evaluation failed!
        //if (!value_print(value, 0)) return false;  // print failed
        if (!event_update_binding(sponsor, event, name, value)) return false;  // update failed!
    } else if (value_equiv(kind, k_conditional)) {
        // { "kind":"conditional", "args":[{ "if":<expression>, "do":[<action>, ...] }, ...] }
        LOG_DEBUG("actor_exec: conditional action", (WORD)kind);
        DATA_PTR args;
        if (!object_get(command, s_args, &args)) {
            LOG_DEBUG("actor_exec: missing 'args' property", (WORD)command);
            return false;  // missing property
        }
        // FIXME: make sure `args` is an Array...
        WORD length;
        if (!array_length(args, &length)) return false;  // args array required!
        WORD i;
        for (i = 0; i < length; i += 1) {  // iterate over conditional clauses...
            DATA_PTR clause;
            if (!array_get(args, i, &clause)) return false;  // clause required!
            DATA_PTR value;
            if (!property_eval(sponsor, event, clause, s_if, &value)) return false;  // evaluation failed!
            if (value_equiv(value, b_true)) {
                DATA_PTR do_expr;
                if (!object_get(clause, s_do, &do_expr)) {
                    LOG_DEBUG("actor_exec: missing 'do' property", (WORD)clause);
                    return false;  // missing property
                }
                if (!actor_exec(sponsor, event, do_expr)) {
                    LOG_WARN("actor_exec: bad do_expr!", (WORD)do_expr);
                    return false;  // execution failed!
                }
                return true;  // success! -- early exit on matching clause.
            }
        }
        LOG_DEBUG("actor_exec: no matching clause", i);
    } else if (value_equiv(kind, k_actor_send)) {
        // { "kind":"actor_send", "message":<dictionary>, "actor":<address> }
        LOG_DEBUG("actor_exec: send action", (WORD)kind);
        DATA_PTR address;
        if (!property_eval(sponsor, event, command, s_actor, &address)) return false;  // evaluation failed!
        if (value_equiv(address, v_null)) {  // shortcut -- if address is null, don't even evaluate message...
            LOG_INFO("actor_exec: ignoring message to null.", null);
            return true;  // success! -- early exit on send-to-null.
        }
        // FIXME: make sure `actor` is a Capability...
        DATA_PTR message;
        if (!property_eval(sponsor, event, command, s_message, &message)) return false;  // evaluation failed!
        if (!sponsor_send(sponsor, address, message)) {
            LOG_WARN("actor_exec: send failed!", (WORD)command);
            return false;  // send failed!
        }
    } else if (value_equiv(kind, k_actor_become)) {
        // { "kind":"actor_become", "behavior":<behavior> }
        LOG_DEBUG("actor_exec: become action", (WORD)kind);
        DATA_PTR behavior;
        if (!property_eval(sponsor, event, command, s_behavior, &behavior)) return false;  // evaluation failed!
        if (!event_update_behavior(sponsor, event, behavior)) return false;  // update failed!
    } else if (value_equiv(kind, k_actor_ignore)) {
        // { "kind":"actor_ignore" }
        LOG_DEBUG("actor_exec: ignore action", (WORD)kind);
    } else if (value_equiv(kind, k_actor_fail)) {
        // { "kind":"actor_fail", "error":<expression> }
        LOG_DEBUG("actor_exec: fail action", (WORD)kind);
        DATA_PTR error;
        if (!property_eval(sponsor, event, command, s_error, &error)) {
            LOG_INFO("actor_exec: DOUBLE-FAULT!", (WORD)command);
            if (!value_print(command, 0)) return false;  // print failed
            return false;  // evaluation failed!
        }
        LOG_WARN("actor_exec: FAIL!", (WORD)error);
        if (!sponsor_fail(sponsor, event, error)) return false;  // double fault!?
        return false;  // stop script execution...
    } else if (value_equiv(kind, k_log_print)) {
        // { "kind":"log_print", "level":<number>, "value":<expression> }  // --DEPRECATED--
        LOG_DEBUG("actor_exec: print action", (WORD)kind);
        DATA_PTR value;
        if (!property_eval(sponsor, event, command, s_value, &value)) return false;  // evaluation failed!
        if (!value_print(value, 0)) return false;  // print failed
    } else {
        LOG_WARN("actor_exec: unknown 'kind' of command", (WORD)kind);
        // FIXME: probably want to return `false` here and fail the script execution, but we just ignore it...
    }
    return true;  // success!
}

BYTE validate_value(DATA_PTR value) {
    LOG_DEBUG("validate_value @", (WORD)value);
    // FIXME: IMPLEMENT SINGLE-PASS PARSE/VALIDATE TO ENSURE SANITY AND CAPTURE MEMOIZED STRINGS...
    if (!value_print(value, 1)) return false;  // print failed!
    return true;  // success!
}

/*
 * WARNING! All the `run_...` procedures return 0 on success, and 1 on failure. (not true/false)
 */

int run_actor_script(sponsor_t * sponsor, event_t * event) {
    LOG_TRACE("run_actor_script: sponsor =", (WORD)sponsor);
    LOG_TRACE("run_actor_script: event =", (WORD)event);
    DATA_PTR behavior;
    if (!event_lookup_behavior(sponsor, event, &behavior)) return false;  // lookup failed!
    DATA_PTR script;
    if (!object_get(behavior, s_script, &script)) {
        LOG_WARN("run_actor_script: script required!", (WORD)behavior);
        return false;  // script required!
    }
    LOG_DEBUG("run_actor_script: script =", (WORD)script);
    //if (!value_print(script, 1)) return 1;  // print failed!
    WORD length;
    if (!array_length(script, &length)) {
        LOG_WARN("run_actor_script: script array required!", (WORD)script);
        return 1;  // top-level array required!
    }
    LOG_INFO("run_actor_script: script array length", length);
    WORD i;
    for (i = 0; i < length; ++i) {
        DATA_PTR command;
        if (!array_get(script, i, &command)
        ||  !object_has(command, s_kind)) {
            LOG_WARN("run_actor_script: command object required!", (WORD)command);
            return 1;  // command object required!
        }
        if (!actor_exec(sponsor, event, command)) {
            LOG_WARN("run_actor_script: failed executing command!", (WORD)command);
            return 1;  // failed executing command!
        }
    }
    LOG_INFO("run_actor_script: completed successfully", i);
    return 0;  // success!
}

int run_actor_config(DATA_PTR item) {
    LOG_TRACE("run_actor_config @", (WORD)item);
    if (!validate_value(item)) return 1;  // validate failed!
    DATA_PTR value;
    WORD actors = 0;
    if (object_get(item, s_actors, &value)
    &&  value_integer(value, &actors)) {
        LOG_INFO("run_actor_config: actors =", actors);
    }
    WORD events = 0;
    if (object_get(item, s_events, &value)
    &&  value_integer(value, &events)) {
        LOG_INFO("run_actor_config: events =", events);
    }
    DATA_PTR script;
    if (!object_get(item, s_script, &script)) {
        LOG_WARN("run_actor_config: script required!", (WORD)item);
        return 1;  // script required!
    }
    LOG_INFO("run_actor_config: script =", (WORD)script);
    sponsor_t * sponsor = new_bounded_sponsor(actors, events, heap_pool);
    assert(sponsor);
    LOG_DEBUG("run_actor_config: sponsor =", (WORD)sponsor);
    /*
     * --WARNING-- THIS CODE HAS INTIMATE KNOWLEDGE OF THE ACTOR AND EVENT STRUCTURES
     */
    BYTE behavior_template[] = { object_n, n_30, n_2,
        utf8, n_4, 'k', 'i', 'n', 'd', utf8, n_14, 'a', 'c', 't', 'o', 'r', '_', 'b', 'e', 'h', 'a', 'v', 'i', 'o', 'r',
        utf8, n_4, 'n', 'a', 'm', 'e', string_0
    };
    DATA_PTR behavior;
    if (!object_add(sponsor, behavior_template, s_script, script, &behavior)) return false;  // allocation failure!
    behavior = TRACK(behavior);
    LOG_LEVEL(LOG_LEVEL_TRACE+1, "run_actor_config: behavior =", (WORD)behavior);
    //if (!value_print(behavior, 1)) return 1;  // print failed!
    actor_t bootstrap_actor = {
        .capability = { null },  // can't send messages to bootstrap
        .scope = {
            .parent = NULL
        },
        .behavior = behavior
    };
    if (!COPY(&bootstrap_actor.scope.state, o_)) return false;  // allocation failure!
    event_t bootstrap_event = {
        .actor = &bootstrap_actor
    };
    if (!COPY(&bootstrap_event.message, o_)) return false;  // allocation failure!
    if (run_actor_script(sponsor, &bootstrap_event) != 0) {
        LOG_WARN("run_actor_config: boot-script execution failed!", (WORD)&bootstrap_event);
        return 1;  // boot-script execution failed!
    }
    while (sponsor_dispatch(sponsor))  // dispatch message-events
        ;
    return 0;  // success!
}

int run_program(DATA_PTR program) {
    LOG_INFO("bootstrap", (WORD)program);
    sponsor_t * sponsor = new_bounded_sponsor(0, 0, heap_pool);
    assert(sponsor);
    LOG_DEBUG("run_program: boot sponsor =", (WORD)sponsor);
    if (!memo_reset(sponsor)) return 1;  // memo reset failed!
    WORD length;
    if (!array_length(program, &length)) {
        LOG_WARN("run_program: top-level array required!", (WORD)program);
        return 1;  // top-level array required!
    }
    LOG_INFO("run_program: top-level array length", length);
    for (WORD i = 0; i < length; ++i) {
        DATA_PTR item;
        DATA_PTR kind;
        if (!array_get(program, i, &item)
        ||  !object_get(item, s_kind, &kind)
        ||  !value_equiv(kind, k_actor_sponsor)) {
            LOG_WARN("run_program: sponsor object required!", (WORD)item);
            return 1;  // sponsor object required!
        }
        if (run_actor_config(item) != 0) {
            LOG_WARN("run_program: failed to start actor configuration!", (WORD)item);
            return 1;  // failed to start!
        }
    }
    if (!memo_reset(sponsor)) return 1;  // memo reset failed!
    return 0;  // success
}
